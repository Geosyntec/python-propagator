""" ArcGIS python toolboxes for ``propagator``.

This contains Classes compatible with ArcGIS python toolbox
infrastructure.

(c) Geosyntec Consultants, 2015.

Released under the BSD 3-clause license (see LICENSE file for more info)

Written by Paul Hobson (phobson@geosyntec.com)

"""


import os
from textwrap import dedent
from collections import OrderedDict

import arcpy
import numpy

import propagator
from propagator import utils


class BaseToolbox_Mixin(object):
    canRunInBackground = True

    def isLicensed(self):
        """ PART OF THE ESRI BLACK BOX.

        Esri says:

            Set whether tool is licensed to execute.


        So I just make this always true b/c it's an open source project
        with a BSD license -- (c) Geosyntec Consultants -- so who cares?

        """
        return True

    def updateMessages(self, parameters): # pragma: no cover
        """ PART OF THE ESRI BLACK BOX.

        Esri says:

            Modify the messages created by internal validation for each
            parameter of the tool.  This method is called after internal
            validation.


        But I have no idea when or how internal validation is called so
        that's pretty useless information.

        """
        return

    def updateParameters(self, parameters): # pragma: no cover
        """ PART OF THE ESRI BLACK BOX.

        Automatically called when any parameter is updated in the GUI.

        The general flow is like this:

          1. User interacts with GUI, filling out some input element
          2. ``self.getParameterInfo`` is called
          3. Parameteter are fed to this method as a list

        I used to set the parameter dependecies in here, but that didn't
        work. So now this does nothing and dependecies are set when the
        parameters (as class properties) are created (i.e., called for
        the first time).

        """
        return

    def getParameterInfo(self):
        """ PART OF THE ESRI BLACK BOX

        This *must* return a list of all of the parameter definitions.

        Esri recommends that you create all of the parameters in here,
        and always return that list. I instead chose to create the list
        from the class properties I've defined. Accessing things with
        meaningful names is always better, in my opinion.

        """
        return self._params_as_list()

    def execute(self, parameters, messages): # pragma: no cover
        """ PART OF THE ESRI BLACK BOX

        This method is called when the tool is actually executed. It
        gets passed magics lists of parameters and messages that no one
        can actually see.

        Due to this mysterious nature, I do the following:

        1) turn all of the elements of the list into a dictionary
           so that we can access them in a meaningful way. This
           means, instead of doing something like

        .. code-block:: python

           dem = parameters[0].valueAsText
           zones = parameters[1].valueAsText
           # yada yada
           nth_param = parameters[n].valueAsText

       for EVERY. SINGLE. PARAMETER, we can instead do something like:

        .. code-block:: python

           params = self._get_parameter_values(parameters, multivals=['elevation'])
           dem = params['dem']
           zones = params['zones'].
           # yada

       This is much cleaner, in my opinion, and we don't have to
       magically know where in the list of parameters e.g., the
       DEM is found. Take note, Esri.

        2) generate a list of scenarios usings :meth:`.make_scenarios`.
        3) loop through those scenarios.
        4) call :meth:`.analyze` on each scenario.
        5) call :meth:`.finish_results` on all of the layers
           generated by the loop.

        """

        params = self._get_parameter_values(parameters)
        self.main_execute(**params)

        return None

    @staticmethod
    def _set_parameter_dependency(downstream, *upstream):
        """ Set the dependecy of a arcpy.Parameter

        Parameters
        ----------
        downstream : arcpy.Parameter
            The Parameter that is reliant on an upstream parameter.
        upstream : acrpy.Parameters
            An arbitraty number of "upstream" parameters on which the
            "downstream" parameter depends.

        Returns
        -------
        None

        See Also
        --------
        http://goo.gl/HcR6WJ

        """

        downstream.parameterDependencies = [u.name for u in upstream]

    @staticmethod
    def _show_header(title, verbose=True):
        """ Creates and shows a little header from a title.

        Parameters
        ----------
        title : str
            The message to be shown
        verbose : bool, optional (True)
            Whether or not the final message should be printed

        Returns
        -------
        header : str
            The formatted title as a header

        Examples
        --------
        >>> Flooder._show_header('Hello, world', verbose=True)
        'Hello, world'
         --------------

        """
        underline = ''.join(['-'] * len(title))
        header = '\n{}\n{}'.format(title, underline)
        utils._status(header, verbose=verbose, asMessage=True, addTab=False)
        return header

    @staticmethod
    def _add_to_map(layerfile, mxd=None):
        """ Adds a layer or raster to the "CURRENT" map.

        Parameters
        ----------
        layerfile : str
            Path to the layer or raster that will be added
        mxd : str, optional
            Path to an ESRI mapdocument.

        Returns
        -------
        ezmd : EasyMapDoc
            The "easy map document" to which ``layerfile`` was added.

        """
        if mxd is None:
            mxd = 'CURRENT'
        ezmd = utils.EasyMapDoc(mxd)
        if ezmd.mapdoc is not None:
            ezmd.add_layer(layerfile)

        return ezmd

    @staticmethod
    def _get_parameter_values(parameters, multivals=None):
        """ Returns a dictionary of the parameters values as passed in from
        the ESRI black box. Keys are the parameter names, values are the
        actual values (as text) of the parameters.

        Parameters
        ----------
        parameters : list of arcpy.Parameter-type thingies
            The list of whatever-the-hell ESRI passes to the
            :meth:`.execute` method of a toolbox.
        multivals : str or list of str, optional
            Parameter names that can take mulitiple values.

        Returns
        -------
        params : dict
            A python dictionary of parameter values mapped to the
            parameter names.

        """

        if multivals is None:
            multivals = []
        elif numpy.isscalar(multivals):
            multivals = [multivals]

        params = {}
        for p in parameters:
            value = p.valueAsText
            if p.name in multivals:
                value = value.split(';')
            params[p.name] = value

        return params

    @staticmethod
    def _prep_input(**kwargs):
        """ TODO:
        Prepares the basic inputs to the :meth:`.analyze` method.

        Parameters
        ----------
        TODO

        Returns
        -------
        TODO

        """

        return None

    @property
    def workspace(self):
        """ The directory or geodatabase in which the analysis will
        occur.

        """

        if self._workspace is None:
            self._workspace = arcpy.Parameter(
                displayName="Analysis WorkSpace",
                name='workspace',
                datatype="DEWorkspace",
                parameterType="Required",
                direction="Input",
                multiValue=False
            )
        return self._workspace

    @property
    def subcatchments(self):
        """ The subcatchments polygons to be used in the analysis.

        """

        if self._subcatchments is None:
            self._subcatchments = arcpy.Parameter(
                displayName="Subcatchments",
                name="subcatchments",
                datatype="DEFeatureClass",
                parameterType="Required",
                direction="Input",
                multiValue=False
            )
            self._set_parameter_dependency(self._subcatchments, self.workspace)
        return self._subcatchments

    @property
    def output_layer(self):
        """ Where the propagated/accumulated data will be saved.

        """

        if self._output_layer is None:
            self._output_layer = arcpy.Parameter(
                displayName="Output subcatchments layer/filename",
                name="output_layer",
                datatype="GPString",
                parameterType="Required",
                direction="Input"
            )
        return self._output_layer

    @staticmethod
    @utils.update_status()
    def finish_results(outputname, results, **kwargs):
        """ Merges and cleans up compiled output from `analyze`.

        Parameters
        ----------
        outputname : str
            Path to where the final file sould be saved.
        results : list of str
            Lists of all of the floods, flooded wetlands, and flooded
            buildings, respectively, that will be merged and deleted.
        sourcename : str, optional
            Path to the original source file of the results. If
            provided, its attbutes will be spatially joined to the
            concatenated results.

        Returns
        -------
        None

        """

        sourcename = kwargs.pop('sourcename', None)
        cleanup = kwargs.pop('cleanup', True)

        if outputname is not None:
            if sourcename is not None:
                tmp_fname = utils.create_temp_filename(outputname, filetype='shape')
                utils.concat_results(tmp_fname, *results)
                utils.join_results_to_baseline(
                    outputname,
                    utils.load_data(tmp_fname, 'layer'),
                    utils.load_data(sourcename, 'layer')
                )
                utils.cleanup_temp_results(tmp_fname)

            else:
                utils.concat_results(outputname, *results)

        if cleanup:
            utils.cleanup_temp_results(*results)


class Propagator(BaseToolbox_Mixin):
    """
    ArcGIS Python toolbox to propagate water quality metrics upstream
    through subcatechments in a watershed.

    Parameters
    ----------
    None

    See also
    --------
    Accumulator

    """
    direction = 'upstream'

    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        # std attributes
        self.label = "1 - Propagate values via subcatechments"
        self.description = dedent("""
        TDB
        """)

        self.multivals = None

        # lazy properties
        self._workspace = None
        self._subcatchments = None
        self._direction = None
        self._monitoring_locations = None
        self._output_layer = None

    @property
    def monitoring_locations(self):
        """ The monitoring location points whose data will be propagated
        to the subcatchments.

        """

        if self._monitoring_locations is None:
            self._monitoring_locations = arcpy.Parameter(
                displayName="Monitoring Locations",
                name="monitoring_locations",
                datatype="DEFeatureClass",
                parameterType="Required",
                direction="Input",
                multiValue=False
            )
            self._set_parameter_dependency(self._monitoring_locations, self.workspace)
        return self._monitoring_locations

    def _params_as_list(self):
        params = [
            self.workspace,
            self.subcatechments,
            self.monitoring_locations,
            self.output_layer,
        ]
        return params

    def analyze(self, topo_array, zones_array, template,
                elev=None, surge=None, slr=None, num=0, **params):
        """ Tool-agnostic helper function for :meth:`.main_execute`.

        Parameters
        ----------
        topo_array : numpy array
            Floating point array of the digital elevation model.
        zones_array : numpy array
            Categorical (integer) array of where each non-zero value
            delineates a tidegate's zone of influence.
        template : arcpy.Raster or tidegates.utils.RasterTemplate
            A raster or raster-like object that define the spatial
            extent of the analysis area. Required attributes are:
              - templatemeanCellWidth
              - templatemeanCellHeight
              - templateextent.lowerLeft
        elev : float, optional
            Custom elevation to be analyzed
        slr : float, optional
            Sea level rise associated with the standard scenario.
        surge : str, optional
            The name of the storm surge associated with the scenario
            (e.g., MHHW, 100yr).
        **params : keyword arguments
            Keyword arguments of analysis parameters generated by
            `self._get_parameter_values`

        Returns
        -------
        floods, flooded_wetlands, flooded_buildings : arcpy.mapping.Layers
            Layers (or None) of the floods and flood-impacted wetlands
            and buildings, respectively.

        """

        # prep input
        elev, title, floods_path = self._prep_flooder_input(
            flood_output=params['flood_output'],
            elev=elev,
            surge=surge,
            slr=slr,
            num=num,
        )

        # define the scenario in the message windows
        self._show_header(title)

        # run the scenario and add its info the output attribute table
        flooded_zones = tidegates.flood_area(
            topo_array=topo_array,
            zones_array=zones_array,
            template=template,
            ID_column=params['ID_column'],
            elevation_feet=elev,
            filename=floods_path,
            num=num,
            verbose=True,
            asMessage=True
        )
        self._add_scenario_columns(flooded_zones.dataSource, elev=elev, surge=surge, slr=slr)

        # setup temporary files for impacted wetlands and buildings
        wl_path = utils.create_temp_filename(floods_path, prefix="_wetlands_", filetype='shape', num=num)
        bldg_path = utils.create_temp_filename(floods_path, prefix="_buildings_", filetype='shape', num=num)

        # asses impacts due to flooding
        fldlyr, wtlndlyr, blgdlyr = tidegates.assess_impact(
            floods_path=floods_path,
            flood_idcol=params['ID_column'],
            wetlands_path=params.get('wetlands', None),
            wetlands_output=wl_path,
            buildings_path=params.get('buildings', None),
            buildings_output=bldg_path,
            cleanup=False,
            verbose=True,
            asMessage=True,
        )

        if wtlndlyr is not None:
            self._add_scenario_columns(wtlndlyr.dataSource, elev=elev, surge=surge, slr=slr)

        return fldlyr, wtlndlyr, blgdlyr

    def main_execute(self, **params):
        """ Performs the flood-impact analysis on multiple flood
        elevations.

        Parameters
        ----------
        workspace : str
            The folder or geodatabase where the analysis will be
            executed.
        dem : str
            Filename of the digital elevation model (topography data)
            to be used in determinging the inundated areas.
        zones : str
            Name of zones of influence layer.
        ID_column : str
            Name of the field in ``zones`` that uniquely identifies
            each zone of influence.
        elevation : list, optional
            List of (custom) flood elevations to be analyzed. If this is
            not provided, *all* of the standard scenarios will be
            evaluated.
        flood_output : str
            Filename where the extent of flooding and damage will be
            saved.
        wetlands, buildings : str, optional
            Names of the wetland and building footprint layers.
        wetland_output, building_output : str, optional
            Filenames where the flooded wetlands and building footprints
            will be saved.

        Returns
        -------
        None

        """

        wetlands = params.get('wetlands', None)
        buildings = params.get('buildings', None)

        all_floods = []
        all_wetlands = []
        all_buildings = []

        with utils.WorkSpace(params['workspace']), utils.OverwriteState(True):

            topo_array, zones_array, template = tidegates.process_dem_and_zones(
                dem=params['dem'],
                zones=params['zones'],
                ID_column=params['ID_column']
            )

            for num, scenario in enumerate(self.make_scenarios(**params)):
                fldlyr, wtlndlyr, blgdlyr = self.analyze(
                    topo_array=topo_array,
                    zones_array=zones_array,
                    template=template,
                    elev=scenario['elev'],
                    surge=scenario['surge_name'],
                    slr=scenario['slr'],
                    num=num,
                    **params
                )
                all_floods.append(fldlyr.dataSource)
                if wetlands is not None:
                    all_wetlands.append(wtlndlyr.dataSource)

                if buildings is not None:
                    all_buildings.append(blgdlyr.dataSource)

            self.finish_results(
                params['flood_output'],
                all_floods,
                msg="Merging and cleaning up all flood results",
                verbose=True,
                asMessage=True,
            )

            if wetlands is not None:
                wtld_output = params.get(
                    'wetland_output',
                    utils.create_temp_filename(params['wetlands'], prefix='output_', filetype='shape')
                )
                self.finish_results(
                    wtld_output,
                    all_wetlands,
                    sourcename=params['wetlands'],
                    msg="Merging and cleaning up all wetlands results",
                    verbose=True,
                    asMessage=True,
                )

            if buildings is not None:
                bldg_output = params.get(
                    'building_output',
                    utils.create_temp_filename(params['buildings'], prefix='output_', filetype='shape')
                )
                self.finish_results(
                    bldg_output,
                    all_buildings,
                    sourcename=params['buildings'],
                    msg="Merging and cleaning up all buildings results",
                    verbose=True,
                    asMessage=True,
                )


class Accumulator(BaseToolbox_Mixin):
    """
    ArcGIS Python toolbox to accumulate subcatechments attributes and
    water quality parameters downstream through a stream.

    Parameters
    ----------
    None

    See also
    --------
    Propagator

    """
    direction = 'downstream'

    def __init__(self):
        """Define the tool (tool name is the name of the class)."""
        # std attributes
        self.label = "2 - Accumulate values via subcatchments"
        self.description = dedent("""
        TDB
        """)

        self.multivals = None

        # lazy properties
        self._workspace = None
        self._subcatchments = None
        self._direction = None
        self._streams = None
        self._output_layer = None

    def _params_as_list(self):
        params = [
            self.workspace,
            self.subcatechments,
            self.streams,
            self.output_layer,
        ]
        return params

    @property
    def streams(self):
        """ The streams who will accumulate attributes from
        subcatchments.

        """

        if self._streams is None:
            self._streams = arcpy.Parameter(
                displayName="Streams",
                name="streams",
                datatype="DEFeatureClass",
                parameterType="Required",
                direction="Input",
                multiValue=False
            )
            self._set_parameter_dependency(self._streams, self.workspace)
        return self._streams

    def _params_as_list(self):
        params = [
            self.workspace,
            self.subcatechments,
            self.direction,
            self._monitoring_locations,
            self.output_layer,
        ]
        return params

    def analyze(self, topo_array, zones_array, template,
                elev=None, surge=None, slr=None, num=0, **params):
        """ Tool-agnostic helper function for :meth:`.main_execute`.

        Parameters
        ----------
        topo_array : numpy array
            Floating point array of the digital elevation model.
        zones_array : numpy array
            Categorical (integer) array of where each non-zero value
            delineates a tidegate's zone of influence.
        template : arcpy.Raster or tidegates.utils.RasterTemplate
            A raster or raster-like object that define the spatial
            extent of the analysis area. Required attributes are:
              - templatemeanCellWidth
              - templatemeanCellHeight
              - templateextent.lowerLeft
        elev : float, optional
            Custom elevation to be analyzed
        slr : float, optional
            Sea level rise associated with the standard scenario.
        surge : str, optional
            The name of the storm surge associated with the scenario
            (e.g., MHHW, 100yr).
        **params : keyword arguments
            Keyword arguments of analysis parameters generated by
            `self._get_parameter_values`

        Returns
        -------
        floods, flooded_wetlands, flooded_buildings : arcpy.mapping.Layers
            Layers (or None) of the floods and flood-impacted wetlands
            and buildings, respectively.

        """

        # prep input
        elev, title, floods_path = self._prep_flooder_input(
            flood_output=params['flood_output'],
            elev=elev,
            surge=surge,
            slr=slr,
            num=num,
        )

        # define the scenario in the message windows
        self._show_header(title)

        # run the scenario and add its info the output attribute table
        flooded_zones = tidegates.flood_area(
            topo_array=topo_array,
            zones_array=zones_array,
            template=template,
            ID_column=params['ID_column'],
            elevation_feet=elev,
            filename=floods_path,
            num=num,
            verbose=True,
            asMessage=True
        )
        self._add_scenario_columns(flooded_zones.dataSource, elev=elev, surge=surge, slr=slr)

        # setup temporary files for impacted wetlands and buildings
        wl_path = utils.create_temp_filename(floods_path, prefix="_wetlands_", filetype='shape', num=num)
        bldg_path = utils.create_temp_filename(floods_path, prefix="_buildings_", filetype='shape', num=num)

        # asses impacts due to flooding
        fldlyr, wtlndlyr, blgdlyr = tidegates.assess_impact(
            floods_path=floods_path,
            flood_idcol=params['ID_column'],
            wetlands_path=params.get('wetlands', None),
            wetlands_output=wl_path,
            buildings_path=params.get('buildings', None),
            buildings_output=bldg_path,
            cleanup=False,
            verbose=True,
            asMessage=True,
        )

        if wtlndlyr is not None:
            self._add_scenario_columns(wtlndlyr.dataSource, elev=elev, surge=surge, slr=slr)

        return fldlyr, wtlndlyr, blgdlyr

    def main_execute(self, **params):
        """ Performs the flood-impact analysis on multiple flood
        elevations.

        Parameters
        ----------
        workspace : str
            The folder or geodatabase where the analysis will be
            executed.
        dem : str
            Filename of the digital elevation model (topography data)
            to be used in determinging the inundated areas.
        zones : str
            Name of zones of influence layer.
        ID_column : str
            Name of the field in ``zones`` that uniquely identifies
            each zone of influence.
        elevation : list, optional
            List of (custom) flood elevations to be analyzed. If this is
            not provided, *all* of the standard scenarios will be
            evaluated.
        flood_output : str
            Filename where the extent of flooding and damage will be
            saved.
        wetlands, buildings : str, optional
            Names of the wetland and building footprint layers.
        wetland_output, building_output : str, optional
            Filenames where the flooded wetlands and building footprints
            will be saved.

        Returns
        -------
        None

        """

        wetlands = params.get('wetlands', None)
        buildings = params.get('buildings', None)

        all_floods = []
        all_wetlands = []
        all_buildings = []

        with utils.WorkSpace(params['workspace']), utils.OverwriteState(True):

            topo_array, zones_array, template = tidegates.process_dem_and_zones(
                dem=params['dem'],
                zones=params['zones'],
                ID_column=params['ID_column']
            )

            for num, scenario in enumerate(self.make_scenarios(**params)):
                fldlyr, wtlndlyr, blgdlyr = self.analyze(
                    topo_array=topo_array,
                    zones_array=zones_array,
                    template=template,
                    elev=scenario['elev'],
                    surge=scenario['surge_name'],
                    slr=scenario['slr'],
                    num=num,
                    **params
                )
                all_floods.append(fldlyr.dataSource)
                if wetlands is not None:
                    all_wetlands.append(wtlndlyr.dataSource)

                if buildings is not None:
                    all_buildings.append(blgdlyr.dataSource)

            self.finish_results(
                params['flood_output'],
                all_floods,
                msg="Merging and cleaning up all flood results",
                verbose=True,
                asMessage=True,
            )

            if wetlands is not None:
                wtld_output = params.get(
                    'wetland_output',
                    utils.create_temp_filename(params['wetlands'], prefix='output_', filetype='shape')
                )
                self.finish_results(
                    wtld_output,
                    all_wetlands,
                    sourcename=params['wetlands'],
                    msg="Merging and cleaning up all wetlands results",
                    verbose=True,
                    asMessage=True,
                )

            if buildings is not None:
                bldg_output = params.get(
                    'building_output',
                    utils.create_temp_filename(params['buildings'], prefix='output_', filetype='shape')
                )
                self.finish_results(
                    bldg_output,
                    all_buildings,
                    sourcename=params['buildings'],
                    msg="Merging and cleaning up all buildings results",
                    verbose=True,
                    asMessage=True,
                )
        """ The flood elevation for a custom scenario.

        """

        if self._elevation is None:
            self._elevation = arcpy.Parameter(
                displayName="Water Surface Elevation",
                name="elevation",
                datatype="GPDouble",
                parameterType="Required",
                direction="Input",
                multiValue=True
            )
        return self._elevation
